<html>

  <head>
    <title>Quantum</title>
    <meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'>
    <link rel='shortcut icon' href='favicon.ico' type='image/x-icon' />
    <link rel='stylesheet' href='style.css' type='text/css' />

    <script src='util/framerate.js'></script>
    <script src='util/light.js'></script>
    <script src='util/physics.js'></script>
    <script src='util/util.js'></script>
    <script src='util/vector.js'></script>
    <script src='population/thing.js'></script>
    <script src='population/box.js'></script>
    <script src='population/dumb_crate.js'></script>
    <script src='population/shelf.js'></script>
    <script src='gl/gl.js'></script>
    <script src='gl-matrix/common.js'></script>
    <script src='gl-matrix/mat3.js'></script>
    <script src='gl-matrix/mat4.js'></script>
    <script src='gl-matrix/vec3.js'></script>
    <script src='gl-matrix/vec4.js'></script>
    <script src='gl/shader_program.js'></script>
    <script src='gl/webgl-utils.js'></script>
    <script src='media/texture.js'></script>
    <script src='media/sound_manager.js'></script>
    <script src='effects/double_explosion.js'></script>
    <script src='effects/image_cross.js'></script>
    <script src='ui/camera.js'></script>
    <script src='world.js'></script>


    <script id="fragment-shader" type="x-shader/x-fragment">
      precision mediump float;

      varying vec2 vTextureCoord;
      varying vec3 vTransformedNormal;
      varying vec4 vPosition;

      uniform bool uUseLighting;
      uniform bool uUseTextures;

      uniform vec3 uAmbientColor;

      uniform vec3 uPointLightingLocation;
      uniform vec3 uPointLightingColor;

      uniform sampler2D uSampler;


      void main(void) {
        vec3 lightWeighting;
        if (!uUseLighting) {
          lightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
          vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);

          float directionalLightWeighting = max(dot(normalize(vTransformedNormal), lightDirection), 0.0);
          lightWeighting = uAmbientColor + uPointLightingColor * directionalLightWeighting;
        }

        vec4 fragmentColor;
        if (uUseTextures) {
          fragmentColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        } else {
          fragmentColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
        gl_FragColor = vec4(fragmentColor.rgb * lightWeighting, fragmentColor.a);
      }
    </script>

    <script id="vertex-shader" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec3 aVertexNormal;
      attribute vec2 aTextureCoord;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform mat3 uNMatrix;

      varying vec2 vTextureCoord;
      varying vec3 vTransformedNormal;
      varying vec4 vPosition;


      void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTextureCoord = aTextureCoord;
        vTransformedNormal = uNMatrix * aVertexNormal;
      }
    </script>


    <script type="text/javascript">

      var gl;
      var shaderProgram;

      function degToRad(degrees) {
        return degrees * Math.PI / 180;
      }


      var cubeVertexPositionBuffer;
      var cubeVertexNormalBuffer;
      var cubeVertexTextureCoordBuffer;
      var cubeVertexIndexBuffer;

      var moonVertexPositionBuffer;
      var moonVertexNormalBuffer;
      var moonVertexTextureCoordBuffer;
      var moonVertexIndexBuffer;

      function initBuffers() {
        cubeVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
          // Front face
          -1.0, -1.0,  1.0,
           1.0, -1.0,  1.0,
           1.0,  1.0,  1.0,
          -1.0,  1.0,  1.0,

          // Back face
          -1.0, -1.0, -1.0,
          -1.0,  1.0, -1.0,
           1.0,  1.0, -1.0,
           1.0, -1.0, -1.0,

          // Top face
          -1.0,  1.0, -1.0,
          -1.0,  1.0,  1.0,
           1.0,  1.0,  1.0,
           1.0,  1.0, -1.0,

          // Bottom face
          -1.0, -1.0, -1.0,
           1.0, -1.0, -1.0,
           1.0, -1.0,  1.0,
          -1.0, -1.0,  1.0,

          // Right face
           1.0, -1.0, -1.0,
           1.0,  1.0, -1.0,
           1.0,  1.0,  1.0,
           1.0, -1.0,  1.0,

          // Left face
          -1.0, -1.0, -1.0,
          -1.0, -1.0,  1.0,
          -1.0,  1.0,  1.0,
          -1.0,  1.0, -1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        cubeVertexPositionBuffer.itemSize = 3;
        cubeVertexPositionBuffer.numItems = 24;

        cubeVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
        var vertexNormals = [
          // Front face
           0.0,  0.0,  1.0,
           0.0,  0.0,  1.0,
           0.0,  0.0,  1.0,
           0.0,  0.0,  1.0,

          // Back face
           0.0,  0.0, -1.0,
           0.0,  0.0, -1.0,
           0.0,  0.0, -1.0,
           0.0,  0.0, -1.0,

          // Top face
           0.0,  1.0,  0.0,
           0.0,  1.0,  0.0,
           0.0,  1.0,  0.0,
           0.0,  1.0,  0.0,

          // Bottom face
           0.0, -1.0,  0.0,
           0.0, -1.0,  0.0,
           0.0, -1.0,  0.0,
           0.0, -1.0,  0.0,

          // Right face
           1.0,  0.0,  0.0,
           1.0,  0.0,  0.0,
           1.0,  0.0,  0.0,
           1.0,  0.0,  0.0,

          // Left face
          -1.0,  0.0,  0.0,
          -1.0,  0.0,  0.0,
          -1.0,  0.0,  0.0,
          -1.0,  0.0,  0.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
        cubeVertexNormalBuffer.itemSize = 3;
        cubeVertexNormalBuffer.numItems = 24;

        cubeVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        var textureCoords = [
          // Front face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,

          // Back face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,

          // Top face
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,

          // Bottom face
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,

          // Right face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,

          // Left face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        cubeVertexTextureCoordBuffer.itemSize = 2;
        cubeVertexTextureCoordBuffer.numItems = 24;

        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
          0, 1, 2,    0, 2, 3,  // Front face
          4, 5, 6,    4, 6, 7,  // Back face
          8, 9, 10,   8, 10, 11,  // Top face
          12, 13, 14,   12, 14, 15, // Bottom face
          16, 17, 18,   16, 18, 19, // Right face
          20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        cubeVertexIndexBuffer.itemSize = 1;
        cubeVertexIndexBuffer.numItems = 36;


        var latitudeBands = 30;
        var longitudeBands = 30;
        var radius = 1;

        var vertexPositionData = [];
        var normalData = [];
        var textureCoordData = [];
        for (var latNumber=0; latNumber <= latitudeBands; latNumber++) {
          var theta = latNumber * Math.PI / latitudeBands;
          var sinTheta = Math.sin(theta);
          var cosTheta = Math.cos(theta);

          for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
            var phi = longNumber * 2 * Math.PI / longitudeBands;
            var sinPhi = Math.sin(phi);
            var cosPhi = Math.cos(phi);

            var x = cosPhi * sinTheta;
            var y = cosTheta;
            var z = sinPhi * sinTheta;
            var u = 1 - (longNumber / longitudeBands);
            var v = 1 - (latNumber / latitudeBands);

            normalData.push(x);
            normalData.push(y);
            normalData.push(z);
            textureCoordData.push(u);
            textureCoordData.push(v);
            vertexPositionData.push(radius * x);
            vertexPositionData.push(radius * y);
            vertexPositionData.push(radius * z);
          }
        }

        var indexData = [];
        for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
          for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
            var first = (latNumber * (longitudeBands + 1)) + longNumber;
            var second = first + longitudeBands + 1;
            indexData.push(first);
            indexData.push(second);
            indexData.push(first + 1);

            indexData.push(second);
            indexData.push(second + 1);
            indexData.push(first + 1);
          }
        }

        moonVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
        moonVertexNormalBuffer.itemSize = 3;
        moonVertexNormalBuffer.numItems = normalData.length / 3;

        moonVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
        moonVertexTextureCoordBuffer.itemSize = 2;
        moonVertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

        moonVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
        moonVertexPositionBuffer.itemSize = 3;
        moonVertexPositionBuffer.numItems = vertexPositionData.length / 3;

        moonVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STREAM_DRAW);
        moonVertexIndexBuffer.itemSize = 1;
        moonVertexIndexBuffer.numItems = indexData.length;
      }


      var moonAngle = 180;
      var cubeAngle = 0;

      function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

        gl.clearColor(world.clearColorRgba[0],
            world.clearColorRgba[1],
            world.clearColorRgba[2],
            1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


        mat4.perspective(gl.pMatrix, PI/4, gl.viewportWidth/gl.viewportHeight,
            0.1, 1000.0);

        gl.useProgram(shaderProgram);

        mat4.identity(gl.mvMatrix);

        worldDOTapplyLights();
        cameraDOTtransorm();
        worldDOTdraw();

      }

      function worldDOTapplyLights() {       
        gl.uniform1i(shaderProgram.useLightingUniform, true);
        gl.uniform3f(shaderProgram.ambientColorUniform, .2, .2, .2);
        gl.uniform3f(shaderProgram.pointLightingLocationUniform, 0, 0, -15);
        gl.uniform3f(shaderProgram.pointLightingColorUniform, .8, .8, .8);

        gl.uniform1i(shaderProgram.useTexturesUniform, false);
      }

      function cameraDOTtransorm() {
        mat4.translate(gl.mvMatrix, gl.mvMatrix, [0, 0, -15]);

        // mat4.rotate(gl.mvMatrix, gl.mvMatrix, degToRad(30), [1, 0, 0]);
      }

      function worldDOTdraw() {

        gl.pushMatrix();
        mat4.rotate(gl.mvMatrix, gl.mvMatrix, degToRad(cubeAngle), [0, 1, 0]);
        mat4.translate(gl.mvMatrix, gl.mvMatrix, [1.25, 0, 0]);
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(shaderProgram.samplerUniform, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        gl.setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        gl.popMatrix();
      }


      function animate() {
        var timeNow = new Date().getTime();
        if (framerate.lastTime != 0) {
          var elapsed = timeNow - framerate.lastTime;
          if (elapsed < 100) {
            var dt = elapsed/1000;
            // camera.advance(dt)
            // world.advance(dt);
            moonAngle += 0.05 * elapsed;
            cubeAngle += 0.05 * elapsed;
          }
          framerate.snapshot();
        }
        framerate.lastTime = timeNow;
      }


      function tick() {
        requestAnimFrame(tick);
        drawScene();
        animate();
        // world.updateLists();
      }


      function webGLStart() {
        var glCanvas = document.getElementById("gl-canvas");
        gl = GL.createGL(glCanvas);
        shaderProgram = ShaderProgram.createShaderProgram();
        initBuffers();

        window.addEventListener('resize',
            util.partial(resize, glCanvas, gl));
        resize(glCanvas, gl);

        Textures.initTextures();

        framerate = new Framerate('framerate');


        // camera = new Camera();
        // camera.setPosition([10, 0, 0])
        // camera.phi = Math.PI/2;

        world = {
          clearColorRgba: [0, 0, 0, 1]
        }
        // world = new World();
        // world.populate();

        tick();
      }

      function resize(glCanvas, gl) {
        console.log(window.innerWidth + " x " + window.innerHeight);
        glCanvas.width = window.innerWidth;
        glCanvas.height = window.innerHeight;
        gl.viewportWidth = window.innerWidth;
        gl.viewportHeight = window.innerHeight;
      };

    </script>


  </head>


  <body onload="webGLStart();">
    <div id='game-div'>
      <canvas id='gl-canvas'></canvas>
    </div>
  </body>

</html>
