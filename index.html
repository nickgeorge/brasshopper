<html>

  <head>
    <title>Quantum</title>
    <meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'>
    <link rel='shortcut icon' href='favicon.ico' type='image/x-icon' />
    <link rel='stylesheet' href='style.css' type='text/css' />

    <script src='util/framerate.js'></script>
    <script src='util/util.js'></script>
    <script src='util/key_code.js'></script>
    <script src='input/hero_listener.js'></script>
    <script src='population/light.js'></script>
    <script src='population/thing.js'></script>
    <script src='population/box.js'></script>
    <script src='population/dumb_crate.js'></script>
    <script src='population/sun.js'></script>
    <script src='population/bullet.js'></script>
    <script src='population/shelf.js'></script>
    <script src='population/sphere.js'></script>
    <script src='population/hero.js'></script>
    <script src='population/pane.js'></script>
    <script src='gl/gl.js'></script>
    <script src='gl/matrix_stack.js'></script>
    <script src='gl/shader_program.js'></script>
    <script src='gl-matrix/common.js'></script>
    <script src='gl-matrix/mat3.js'></script>
    <script src='gl-matrix/mat4.js'></script>
    <script src='gl-matrix/vec2.js'></script>
    <script src='gl-matrix/vec3.js'></script>
    <script src='gl-matrix/vec4.js'></script>
    <script src='gl-matrix/extensions.js'></script>
    <script src='media/texture.js'></script>
    <script src='media/sound_manager.js'></script>
    <script src='effects/double_explosion.js'></script>
    <script src='effects/image_cross.js'></script>
    <script src='ui/hud.js'></script>
    <script src='ui/camera.js'></script>
    <script src='world.js'></script>


    <script id="fragment-shader" type="x-shader/x-fragment">
      precision highp float;

      uniform mat4 uViewMatrix;

      varying vec2 vTextureCoord;
      varying vec3 vTransformedNormal;
      varying vec4 vPosition;
      varying vec3 vEyeDirection;

      uniform bool uUseLighting;
      uniform bool uUseTexture;

      uniform vec3 uPointLightingLocation;
      uniform vec4 uColor; 
      uniform vec3 uAmbientColor;
      uniform vec3 uPointLightingColor;

      uniform sampler2D uSampler;

      void main(void) {
        vec3 lightWeighting;
        if (!uUseLighting) {
          lightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
          vec3 relativeLightPosition = uPointLightingLocation - vPosition.xyz;
          vec3 lightDirection = normalize(relativeLightPosition);
          vec3 normal = normalize(vTransformedNormal);
          vec3 reflectionDirection = reflect(-lightDirection, normal);

          float directionalLightWeighting = max(0.0, dot(
              normal,
              lightDirection));

          float specularLightWeighting = 0.0;
          if (directionalLightWeighting > 0.0) {
            specularLightWeighting = pow(
              max(
                  dot(reflectionDirection, vEyeDirection),
                  0.0),
              8.0) * 1.0;
          }

          float distance = length(relativeLightPosition);
          float distanceDropoff = (1.0/(distance*distance/50625.0 + 1.0)) * 1.0 + 0.0;
          
          lightWeighting = uAmbientColor + 
              1.0 * uPointLightingColor * specularLightWeighting * distanceDropoff +
              1.0 * uPointLightingColor * directionalLightWeighting * distanceDropoff;
        }

        vec4 fragmentColor;
        if (uUseTexture) {
          fragmentColor = texture2D(uSampler, vTextureCoord);
        } else {
          fragmentColor = uColor;
        }
        gl_FragColor = vec4(fragmentColor.rgb * lightWeighting, fragmentColor.a);
      }
    </script>

    <script id="vertex-shader" type="x-shader/x-vertex">
      precision highp float;

      attribute vec3 aVertexPosition;
      attribute vec3 aVertexNormal;
      attribute vec2 aTextureCoord;

      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;
      uniform mat4 uPerspectiveMatrix;
      uniform mat3 uNormalMatrix;
      uniform vec4 uColor;
      uniform vec3 uPointLightingLocation;
      uniform vec3 uEyeLocation;

      varying vec2 vTextureCoord;
      varying vec3 vTransformedNormal;
      varying vec4 vPosition;
      varying vec4 vColor;
      varying vec3 vEyeDirection;


      void main(void) {
        vPosition = uModelMatrix * vec4(aVertexPosition, 1.0);
        
        gl_Position = uPerspectiveMatrix * uViewMatrix * vPosition;
        vTextureCoord = aTextureCoord;
        vTransformedNormal = uNormalMatrix * aVertexNormal;
        vEyeDirection = normalize(uEyeLocation - vPosition.xyz);
      }
    </script>


    <script type="text/javascript">

      var gl;
      var shaderProgram;
      var framerate;

      var world;
      var camera;

      function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

        gl.clearColor(
            world.clearColorRgba[0],
          world.clearColorRgba[1],
            world.clearColorRgba[2],
            1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


        mat4.perspective(gl.perspectiveMatrix,
            PI/4, gl.viewportWidth/gl.viewportHeight,
            .1, 9450.0);

        gl.useProgram(shaderProgram);

        mat4.identity(gl.modelMatrix);

        world.draw();

        hud.render();
      }

      function advanceWorld() {
        var timeNow = new Date().getTime();
        if (framerate.lastTime != 0) {
          var elapsed = timeNow - framerate.lastTime;
          if (elapsed < 100) {
            var dt = elapsed/1000;
            world.advance(dt);
          }
          framerate.snapshot();
        }
        framerate.lastTime = timeNow;
      }


      function tick() {
        requestAnimationFrame(tick);
        if (!heroListener.mouseIsLocked) return;
        advanceWorld();
        drawScene();
      }


      function webGLStart() {
        framerate = new Framerate('framerate');
        var hudCanvas = document.getElementById('hud-canvas')
        var glCanvas = document.getElementById("gl-canvas");
        gl = GL.createGL(glCanvas);
        shaderProgram = ShaderProgram.createShaderProgram();
        Textures.initTextures();


        window.addEventListener('resize',
            util.partial(resize, hudCanvas, glCanvas, gl));
        resize(hudCanvas, glCanvas, gl);

        Textures.initTextures();

        hud = new HUD(hudCanvas, framerate);
        var gameDiv = document.getElementById('game-div');
        heroListener = new HeroListener(gameDiv);
        heroListener.attachEvents();

        world = new World();
        world.populate();

        drawScene();
        tick();
      }

      function resize(hudCanvas, glCanvas, gl) {
        hudCanvas.width = window.innerWidth;
        hudCanvas.height = window.innerHeight;
        glCanvas.width = window.innerWidth;
        glCanvas.height = window.innerHeight;
        gl.viewportWidth = window.innerWidth;
        gl.viewportHeight = window.innerHeight;
      };

      /**
       * Provides requestAnimationFrame in a cross-browser way.
       */
      requestAnimationFrame = (function() {
        return window.requestAnimationFrame ||
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame ||
           window.oRequestAnimationFrame ||
           window.msRequestAnimationFrame ||
           function(callback, element) {
             window.setTimeout(callback, 1000/60);
           };
      })();

    </script>
  </head>

  <body onload="webGLStart();">
    <div id='game-div'>
      <canvas id='gl-canvas'>
      </canvas>
      <canvas id='hud-canvas'></canvas>
    </div>
  </body>
</html>
